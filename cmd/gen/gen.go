package main

import (
	"errors"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"strings"
)

type StructInfo struct {
	Type          *ast.StructType
	VisitorMethod *ast.Field
	NodeType      string
}

func main() {
	astFile := "ast.go"
	// this facilitates testing
	if _, err := os.Stat(astFile); errors.Is(err, fs.ErrNotExist) {
		astFile = filepath.Join("internal", "ast", astFile)
	}

	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, astFile, nil, 0)
	if err != nil {
		log.Fatal(err)
	}

	visitors := make(map[string]*ast.InterfaceType, len(f.Decls))
	ifaces := make(map[string]*ast.InterfaceType, len(f.Decls))
	structs := make(map[string]*StructInfo, len(f.Decls))
	nodes := make([]string, 0, len(f.Decls))

	// record all top-level interface and struct declarations
	for _, decl := range f.Decls {
		d, ok := decl.(*ast.GenDecl)
		if !ok || d.Tok != token.TYPE {
			continue
		}

		for _, spec := range d.Specs {
			ts := spec.(*ast.TypeSpec)
			switch t := ts.Type.(type) {
			case *ast.InterfaceType:
				if strings.HasSuffix(ts.Name.Name, "Visitor") {
					visitors[strings.TrimSuffix(ts.Name.Name, "Visitor")] = t
				} else {
					ifaces[ts.Name.Name] = t
				}
			case *ast.StructType:
				structs[ts.Name.Name] = &StructInfo{Type: t}
				nodes = append(nodes, ts.Name.Name)
			}
		}
	}

	// fill additional node struct information
	for v, vv := range visitors {
		for _, met := range vv.Methods.List {
			ft := met.Type.(*ast.FuncType)
			id := ft.Params.List[0].Type.(*ast.StarExpr).X.(*ast.Ident)

			if info, ok := structs[id.Name]; ok {
				info.VisitorMethod = met
				info.NodeType = v
			}
		}
	}

	// Write the generated file
	outFile := filepath.Join(filepath.Dir(astFile), strings.ReplaceAll(filepath.Base(astFile), "ast", "ast_accepts"))
	out, err := os.OpenFile(outFile, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
	if err != nil {
		log.Fatal(err)
	}
	defer out.Close()

	_, err = fmt.Fprint(out, "// Code generated by \"go run ../../cmd/gen/gen.go\"; DO NOT EDIT.\n\n")
	if err != nil {
		log.Fatal(err)
	}
	_, err = fmt.Fprint(out, "package ast\n\n")
	if err != nil {
		log.Fatal(err)
	}

	for _, name := range nodes {
		info := structs[name]
		if iface, ok := ifaces[info.NodeType]; ok {
			for _, met := range iface.Methods.List {
				metft := met.Type.(*ast.FuncType)

				decl := &ast.FuncDecl{
					Name: ast.NewIdent(met.Names[0].Name),
					Recv: &ast.FieldList{
						List: []*ast.Field{{
							Names: []*ast.Ident{ast.NewIdent("n")},
							Type:  &ast.StarExpr{X: ast.NewIdent(name)},
						}},
					},
					Type: &ast.FuncType{
						Params:  metft.Params,
						Results: metft.Results,
					},
					Body: &ast.BlockStmt{},
				}

				if met.Names[0].Name == "Accept" {
					paramName := metft.Params.List[0].Names[0].Name
					decl.Body = &ast.BlockStmt{
						List: []ast.Stmt{&ast.ReturnStmt{
							Results: []ast.Expr{&ast.CallExpr{
								Fun: &ast.SelectorExpr{
									X:   ast.NewIdent(paramName),
									Sel: info.VisitorMethod.Names[0],
								},
								Args: []ast.Expr{ast.NewIdent("n")},
							}},
						}},
					}
				}

				err = format.Node(out, fset, decl)
				if err != nil {
					log.Fatal(err)
				}
				_, err = fmt.Fprint(out, "\n\n")
				if err != nil {
					log.Fatal(err)
				}
			}
		}
	}
}
